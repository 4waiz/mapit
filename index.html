<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EDGE LIF — Indoor Wayfinder (Auto-Animated)</title>
<style>
  :root{
    --brand:#da7800;
    --brand-dark:#834902;
    --bg:#0e1117;
    --muted:#9aa3af;
    --glow:#ffd54a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font:16px/1.45 Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .app{display:grid;grid-template-columns:430px 1fr;height:100%}

  /* Sidebar */
  .sidebar{padding:28px;background:linear-gradient(180deg,var(--brand),var(--brand-dark));display:flex;flex-direction:column;gap:16px}
  .title{font-weight:800;letter-spacing:.06em;opacity:.95}
  .panel{background:rgba(0,0,0,.22);border-radius:16px;padding:16px;backdrop-filter:blur(4px);box-shadow:0 10px 26px rgba(0,0,0,.22), inset 0 1px 2px rgba(0,0,0,.3);}
  label{font-size:.9rem;opacity:.95;display:block;margin:8px 0 6px 6px;color:#111;font-weight:600;}
  .row{display:flex;gap:10px}


  /* dropdowns readable */
  select{
    width:100%;padding:12px 14px;border:0;border-radius:12px;
    color:#000;background:#fff;outline:none;
  }
  option{color:#000;background:#fff}
  .swap{width:auto;padding:12px;border-radius:12px;background:#10131a;color:#fff;border:0;cursor:pointer;font-size:1.2rem;}

  .chips{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px}
  .chip{background:rgba(14,16,22,.8);border:1px solid rgba(255,255,255,.1);border-radius:999px;padding:10px 14px;font-size:.95rem;cursor:pointer;opacity:.9;transition:all .2s ease;}
  .chip:hover{opacity:1;background:var(--bg); transform:translateY(-2px);}

  .routes{display:flex;flex-direction:column;gap:10px;max-height:38vh;overflow:auto}
  .route{background:#0e1016;border-radius:12px;padding:12px;transition:background .2s ease;border:1px solid transparent;}
  .route:hover{background:#1a2030; border-color:rgba(255,255,255,.1);}
  .route h4{margin:0 0 6px 0;font-size:1rem}
  .small{color:rgba(255,255,255,.85);font-size:.92rem}

  /* Map side */
  .map-wrap{
    position:relative;
    background:
      linear-gradient(rgba(14,17,23,.1) 1px, transparent 1px),
      linear-gradient(90deg, rgba(14,17,23,.1) 1px, transparent 1px);
    background-size: 30px 30px, 30px 30px;
    animation: scan 10s linear infinite;
  }
  @keyframes scan {
    0% { background-position: 0 0; }
    100% { background-position: 30px 30px; }
  }

  .legend{position:absolute;right:16px;bottom:16px;background:#151a23;padding:8px 12px;border-radius:10px;font-size:.9rem;opacity:.9; backdrop-filter:blur(2px);}
  .toolbar{position:absolute;left:16px;top:16px;background:#151a23;padding:8px 12px;border-radius:10px;opacity:.9; backdrop-filter:blur(2px);}
  .map{width:100%;height:100%}

  /* Destination "light up" */
  #rooms .lit{
    stroke: var(--glow);
    fill: #242c40;
    filter: url(#glow);
    animation: flash 900ms ease-out 1;
  }
  /* MODIFIED: Added a subtle scale to the flash for more impact */
  @keyframes flash{
    0%  { opacity:.9; transform: scale(1); }
    60% { opacity:1; transform: scale(1.02); }
    100%{ opacity:.95; transform: scale(1); }
  }
  
  #startDot{
    animation: pulse 1.5s ease-in-out infinite;
  }
  @keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.4); opacity: 0.7; }
    100% { transform: scale(1); opacity: 1; }
  }


  @media (pointer:coarse){
    select,.chip{font-size:1.05rem;padding:16px}
  }

/* =============================
   Responsive & 8K-ready tweaks
   ============================= */
html, body { height: 100dvh; }
html { font-size: clamp(14px, 0.9vw, 22px); }

.app{
  /* Sidebar scales between 360–520px, ~22vw on ultrawide */
  grid-template-columns: minmax(280px, clamp(360px, 22vw, 520px)) 1fr;
  min-height: 100dvh;
}

.sidebar{
  padding: max(20px, calc(16px + env(safe-area-inset-top))) max(20px, calc(16px + env(safe-area-inset-right))) max(20px, calc(16px + env(safe-area-inset-bottom))) max(20px, calc(16px + env(safe-area-inset-left)));
}

.title{ font-size: clamp(1rem, 1.6vw, 1.8rem); }
.panel{ border-radius: clamp(12px, 1.2vw, 18px); }
label{ font-size: clamp(.9rem, 1.1vw, 1rem); }

select{ font-size: clamp(0.95rem, 1.1vw, 1.05rem); }
.swap{ font-size: clamp(1.1rem, 1.5vw, 1.25rem); }

.routes{ max-height: min(38vh, 42svh); }
.chip{ font-size: clamp(.9rem, 1.1vw, 1rem); }

/* Scale SVG label text on huge displays */
#map text{ font-size: clamp(12px, 1.1vw, 24px); }

/* Improve performance and accessibility */
@media (prefers-reduced-motion: reduce){
  .map-wrap{ animation: none !important; }
  #startDot{ animation: none !important; }
}

/* Tablet / Narrow laptop: stack sidebar above map */
@media (max-width: 1024px){
  .app{ display: grid; grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
  .sidebar{ position: sticky; top: 0; z-index: 2; }
  .map-wrap{ min-height: 60vh; }
}

/* Phones */
@media (max-width: 640px){
  .sidebar{ gap: 12px; }
  .row{ flex-direction: column; }
  .chips{ gap: 6px; }
  .legend, .toolbar{ font-size: .85rem; }
}

/* Ultra-wide (>= 3840px): gently increase UI density without going huge */
@media (min-width: 3840px){
  .panel{ padding: clamp(16px, 1vw, 22px); }
  .legend, .toolbar{ font-size: clamp(.9rem, 0.9vw, 1.1rem); }
  .routes{ max-height: 44vh; }
}

/* Ensure the SVG never causes overflow on very wide screens */
.map{ width: 100%; height: 100%; max-width: 100vw; max-height: 100dvh; }

</style>
</head>
<body>
<div class="app">
  <!-- SIDEBAR -->
  <aside class="sidebar">
    <div class="title">EDGE LIF — INDOOR WAYFINDER</div>

    <div class="panel">
      <label>From</label>
      <div class="row">
        <select id="from">
          <option value="reception">Reception</option>
          <option value="lobby">Lobby</option>
          <option value="room1">Room 1</option>
          <option value="room2">Room 2</option>
          <option value="conference">Conference</option>
          <option value="exit">Exit</option>
        </select>
        <button class="swap" id="swap" title="Swap">⇅</button>
      </div>

      <label>To</label>
      <select id="to">
        <option value="room1">Room 1</option>
        <option value="room2">Room 2</option>
        <option value="conference">Conference</option>
        <option value="lobby">Lobby</option>
        <option value="reception">Reception</option>
        <option value="exit">Exit</option>
      </select>

      <div class="chips">
        <div class="chip" data-from="lobby" data-to="room1">Lobby → Room 1</div>
        <div class="chip" data-from="reception" data-to="room2">Reception → Room 2</div>
        <div class="chip" data-from="reception" data-to="conference">Reception → Conference</div>
        <div class="chip" data-from="room1" data-to="exit">Room 1 → Exit</div>
      </div>
    </div>

    <div class="panel">
      <div style="font-weight:700;margin-bottom:10px">Suggested route</div>
      <div id="summary" class="small">Auto-animates every 10 seconds.</div>
      <div class="routes" id="steps"></div>
    </div>
  </aside>

  <!-- MAP -->
  <section class="map-wrap">
    <div class="toolbar">Tap map to log SVG coords</div>
    <div class="legend">● START · ⤳ moving arrow · destination lights up</div>

    <svg id="map" class="map" viewBox="0 0 1200 600" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="routeGradient" x1="0" y1="0" x2="1200" y2="0" gradientUnits="userSpaceOnUse">
          <stop offset="0%" stop-color="var(--brand)"/>
          <stop offset="100%" stop-color="var(--glow)"/>
        </linearGradient>
        <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>

      <!-- background -->
      <rect x="0" y="0" width="1200" height="600" fill="#0e1117"/>

      <!-- building shell -->
      <g fill="#141a24" stroke="#273049" stroke-width="2">
        <rect x="60" y="120" width="1080" height="360" rx="14"/>
      </g>

      <!-- main corridor -->
      <rect x="140" y="280" width="920" height="62" rx="12" fill="#1a2030" stroke="#2a3449" stroke-width="2"/>

      <!-- rooms -->
      <g id="rooms" fill="#1c2436" stroke="#313a52" stroke-width="2">
        <rect id="room1Rect" x="240" y="160" width="140" height="100" rx="12"/><!-- Room 1 -->
        <rect id="room2Rect" x="440" y="160" width="140" height="100" rx="12"/><!-- Room 2 -->
        <rect id="confRect"  x="780" y="160" width="160" height="100" rx="12"/><!-- Conference -->
        <rect id="receptionRect" x="950" y="260" width="110" height="80"  rx="12"/><!-- Reception -->
        <rect id="exitRect" x="80"  y="260" width="80"  height="80"  rx="12"/><!-- Exit -->
      </g>

      <!-- labels -->
      <g font-family="Inter,Arial" font-size="16" fill="#cfd6e6" opacity=".92">
        <text x="260" y="210">Room 1</text>
        <text x="460" y="210">Room 2</text>
        <text x="795" y="210">Conference</text>
        <text x="960" y="305">Reception</text>
        <text x="97"  y="305">Exit</text>
      </g>

      <!-- FULL route (dim) -->
      <!-- MODIFIED: Subtler stroke color and opacity -->
      <path id="routeBg" fill="none" stroke="#242c40" stroke-width="10" stroke-linecap="round" stroke-linejoin="round" opacity=".5"/>
      <!-- PROGRESS route (animated) -->
      <path id="routeFg" fill="none" stroke="url(#routeGradient)" stroke-width="10" stroke-linecap="round" stroke-linejoin="round" opacity=".98" filter="url(#glow)"/>

      <!-- START dot (now animated with CSS) -->
      <g id="startMarker" style="display:none" filter="url(#glow)">
        <circle id="startDot" r="8" fill="var(--brand)"/>
      </g>

      <!-- MOVING ARROW -->
      <g id="arrow" style="display:none" filter="url(#glow)">
        <polygon points="0,0 -16,-9 -16,9" fill="#0e1117" stroke="var(--glow)" stroke-width="1.5"/>
      </g>
    </svg>
  </section>
</div>

<script>
/* =========================
   Auto-animated indoor routing
   ========================= */
const PX_TO_M = 0.12;
const WALK_MPS = 1.2;

const NODES = {
  reception:{x:1005,y:300,label:'Reception'}, lobby:{x:900,y:300,label:'Lobby'}, j1:{x:700,y:300,label:'Junction 1'},
  j2:{x:500,y:300,label:'Junction 2'}, j3:{x:300,y:300,label:'Junction 3'}, exit:{x:120,y:300,label:'Exit'},
  room1_d:{x:300,y:260,label:'Room 1 Door'}, room2_d:{x:500,y:260,label:'Room 2 Door'}, conf_d:{x:860,y:260,label:'Conference Door'},
  room1:{x:310,y:210,label:'Room 1'}, room2:{x:510,y:210,label:'Room 2'}, conference:{x:860,y:210,label:'Conference'}
};

const TARGET_RECT = { room1:'room1Rect', room2:'room2Rect', conference:'confRect', reception:'receptionRect', exit:'exitRect' };

const EDGES = [
  ['reception','lobby'],['lobby','j1'],['j1','j2'],['j2','j3'],['j3','exit'],
  ['room1_d','j3'],['room2_d','j2'],['conf_d','lobby'],
  ['room1_d','room1'],['room2_d','room2'],['conf_d','conference']
];

const G={}; function d(a,b){const dx=NODES[a].x-NODES[b].x,dy=NODES[a].y-NODES[b].y;return Math.hypot(dx,dy);}
for(const [a,b] of EDGES){const w=d(a,b);(G[a]??=[]).push({to:b,w});(G[b]??=[]).push({to:a,w});}

function shortest(start,end){
  const Q=new Set(Object.keys(NODES)); const dist={},prev={}; for(const k of Q) dist[k]=Infinity; dist[start]=0;
  while(Q.size){
    let u=null,best=Infinity; for(const k of Q) if(dist[k]<best){best=dist[k];u=k;}
    Q.delete(u); if(u===end || best===Infinity) break;
    for(const {to,w} of (G[u]||[])){ if(!Q.has(to)) continue; const alt=dist[u]+w; if(alt<dist[to]){dist[to]=alt; prev[to]=u;}}
  }
  const path=[]; let u=end; if(!(u in prev) && u!==start) return null;
  while(u){ path.unshift(u); if(u===start) break; u=prev[u]; } return path;
}

const svg = document.getElementById('map');
const routeBg = document.getElementById('routeBg');
const routeFg = document.getElementById('routeFg');
const startMarker = document.getElementById('startMarker');
const arrow = document.getElementById('arrow');
const grad = document.getElementById('routeGradient');
const summaryEl = document.getElementById('summary');
const stepsEl = document.getElementById('steps');

/* =======================================
   NEW & IMPROVED: Path rounding function
   Creates clean, rounded corners.
   ======================================= */
function createRoundedPath(points, radius) {
    if (points.length < 2) return '';
    let d = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length - 1; i++) {
        const p_prev = points[i - 1];
        const p_curr = points[i];
        const p_next = points[i + 1];

        const v1 = { x: p_prev.x - p_curr.x, y: p_prev.y - p_curr.y };
        const v2 = { x: p_next.x - p_curr.x, y: p_next.y - p_curr.y };

        const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
        const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

        // Normalize vectors
        v1.x /= mag1; v1.y /= mag1;
        v2.x /= mag2; v2.y /= mag2;

        // Check for collinear points (straight line)
        const dotProduct = v1.x * v2.x + v1.y * v2.y;
        if (Math.abs(dotProduct) > 0.999) {
            d += ` L ${p_curr.x} ${p_curr.y}`;
            continue;
        }

        const rad = Math.min(radius, mag1 / 2, mag2 / 2);

        const turn_p1 = { x: p_curr.x + rad * v1.x, y: p_curr.y + rad * v1.y };
        const turn_p2 = { x: p_curr.x + rad * v2.x, y: p_curr.y + rad * v2.y };
        
        d += ` L ${turn_p1.x} ${turn_p1.y}`;
        d += ` Q ${p_curr.x} ${p_curr.y}, ${turn_p2.x} ${turn_p2.y}`;
    }
    d += ` L ${points[points.length - 1].x} ${points[points.length - 1].y}`;
    return d;
}
/* ======================================= */

function meters(px){return px*PX_TO_M;}
function timeFmt(sec){if(sec<60) return `${Math.round(sec)} sec`; const m=Math.floor(sec/60),s=Math.round(sec%60); return `${m} min${s?` ${s}s`:''}`;}

function lightUp(targetKey){
  const id = TARGET_RECT[targetKey]; if(!id) return;
  const el = document.getElementById(id);
  el.classList.remove('lit'); void el.offsetWidth;
  el.classList.add('lit');
  setTimeout(()=> el.classList.remove('lit'), 950);
}

let animReq=null, loopTimer=null;
function cancelAnim(){ if(animReq){ cancelAnimationFrame(animReq); animReq=null; } if(loopTimer){ clearTimeout(loopTimer); loopTimer=null; } }

function animateAlong(pathEl, seconds, onDone){
  const total = pathEl.getTotalLength();
  routeFg.style.strokeDasharray = total;
  routeFg.style.strokeDashoffset = total;
  arrow.style.display = 'block';

  const t0 = performance.now();
  // MODIFIED: Snappier animation timing
  const dur = Math.min(Math.max(seconds * 0.7, 1.5), 5000); 

  function frame(now){
    const t = Math.min((now - t0)/dur, 1);
    const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    const len = total * ease;

    routeFg.style.strokeDashoffset = total - len;

    const p = pathEl.getPointAtLength(Math.max(len - 0.1, 0));
    const p2= pathEl.getPointAtLength(Math.min(len + 0.1, total));
    const angle = Math.atan2(p2.y - p.y, p2.x - p.x) * 180 / Math.PI;
    arrow.setAttribute('transform', `translate(${p.x},${p.y}) rotate(${angle})`);

    if(t < 1){ animReq = requestAnimationFrame(frame); } else { animReq = null; onDone && onDone(); }
  }
  animReq = requestAnimationFrame(frame);
}

function plan(from,to){
  cancelAnim();

  const keys = shortest(from,to);
  if(!keys){ summaryEl.textContent='No route found.'; stepsEl.innerHTML=''; routeBg.setAttribute('d',''); routeFg.setAttribute('d',''); arrow.style.display='none'; startMarker.style.display='none'; return; }

  const points = keys.map(k => NODES[k]);
  const dStr = createRoundedPath(points, 30); // MODIFIED: Use the new superior rounding function

  routeBg.setAttribute('d', dStr);
  routeFg.setAttribute('d', dStr);

  const a=NODES[keys[0]], b=NODES[keys[keys.length-1]];
  grad.setAttribute('x1', a.x); grad.setAttribute('y1', a.y);
  grad.setAttribute('x2', b.x); grad.setAttribute('y2', b.y);

  startMarker.style.display='block';
  startMarker.setAttribute('transform', `translate(${a.x},${a.y})`);

  let pxLen=0; for(let i=1;i<keys.length;i++) pxLen += d(keys[i-1],keys[i]);
  const m = meters(pxLen), sec = m / WALK_MPS;
  summaryEl.innerHTML = `<b>${NODES[from].label}</b> → <b>${NODES[to].label}</b> · ${m.toFixed(0)} m · ${timeFmt(sec)}`;

  stepsEl.innerHTML='';
  for(let i=0;i<keys.length;i++){
    const here = keys[i], nxt = keys[i+1];
    const div = document.createElement('div'); div.className='route';
    const title = i===0?'START: ': i===keys.length-1?'ARRIVE: ':'→ ';
    div.innerHTML = `<h4>${title}${NODES[here].label}</h4>` + (nxt?`<div class="small">Proceed to <b>${NODES[nxt].label}</b></div>`:'');
    stepsEl.appendChild(div);
  }

  animateAlong(routeFg, sec, ()=>{
    lightUp(keys[keys.length-1]);
    loopTimer = setTimeout(()=> animateAlong(routeFg, sec, ()=> lightUp(keys[keys.length-1]) ), 10000);
  });
}

const fromSel = document.getElementById('from');
const toSel   = document.getElementById('to');
document.getElementById('swap').addEventListener('click', ()=>{
  const a=fromSel.value,b=toSel.value; fromSel.value=b; toSel.value=a; plan(fromSel.value,toSel.value);
});
document.querySelectorAll('.chip').forEach(c=> c.addEventListener('click', ()=>{
  fromSel.value=c.dataset.from; toSel.value=c.dataset.to; plan(fromSel.value,toSel.value);
}));

[fromSel,toSel].forEach(el=> el.addEventListener('change', ()=> plan(fromSel.value,toSel.value)));

svg.addEventListener('click', (e)=>{
  const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
  const p = pt.matrixTransform(svg.getScreenCTM().inverse());
  console.log('SVG coords:', Math.round(p.x), Math.round(p.y));
});

fromSel.value='reception'; toSel.value='room2'; // Set default to the problematic route
plan(fromSel.value,toSel.value);
</script>
</body>
</html>